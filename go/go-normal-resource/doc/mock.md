## Mockを利用したテストコード

### 1. Mockとは...
```
クラスの動作をシュミレートするためのオブジェクトであり、
オブジェクトのメソッドがどう呼ばれて何を返すか、インターフェースも含めたテストのために使用するためのもの
```
[interfceテストの必要性については@amasdaさんのブログに記載されております](https://amasuda.xyz/post/2019-03-24-interface-and-mocking/)

今回は`gomock`と呼ばれるGoのモックパッケージを使用してテストコードを書いてみます。

### 2. gomockを利用してインタフェースのテストコードを記述

今回のテストディレクトリについてはこんな感じで作成していきます。

```sh
├── interface.go #interfaceのコード
├── mock #mockのテストコードを格納するためのディレクトリ
│   └── mock.go # mockgenでと呼ばれるモックジェネレータを使用して作成する。
└── mock_test.go # テストコード
```
対象となるインタフェースモデルを作成していきます

`interfce.go`

```go
package mockTest

type DoSomeThingInterface interface {
	Method1(s string) string
	Method2(i int) int
}
```
mockgenを用いて`interface.go`からモックコード自動生成します。

```sh
$ cd $GOPATH
$ go get github.com/golang/mock/gomock
$ go get github.com/golang/mock/mockgen

$ cd src/interface-test
# mockgenコマンドを利用してinterface.goのモックコードをmockディレクトリ配下に生成する。
$ mockgen -source interface.go -destination mock/mock.go

# 念のためlsコマンドなどでファイルのサイズを確認して0kbでないことを確認します。
$ ll mock/ | grep mock.go
-rw-r--r--  1 hacknatural  staff  1786 May 26 09:50 mock.go
```

ここまでできたら自動生成した`mock.go`の中身を確認してみます。
`mock.go`ファイルの中で`interface.go`で定義したメソッドが実装されていることがわかると思います。

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go

// Package mock_mockTest is a generated GoMock package.
package mock_mockTest

import (
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockFirstModel is a mock of FirstModel interface.
type MockFirstModel struct {
	ctrl     *gomock.Controller
	recorder *MockFirstModelMockRecorder
}

// MockFirstModelMockRecorder is the mock recorder for MockFirstModel.
type MockFirstModelMockRecorder struct {
	mock *MockFirstModel
}

// NewMockFirstModel creates a new mock instance.
func NewMockFirstModel(ctrl *gomock.Controller) *MockFirstModel {
	mock := &MockFirstModel{ctrl: ctrl}
	mock.recorder = &MockFirstModelMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFirstModel) EXPECT() *MockFirstModelMockRecorder {
	return m.recorder
}

// Method1 mocks base method.
func (m *MockFirstModel) Method1(s string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Method1", s)
	ret0, _ := ret[0].(string)
	return ret0
}

// Method1 indicates an expected call of Method1.
func (mr *MockFirstModelMockRecorder) Method1(s interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Method1", reflect.TypeOf((*MockFirstModel)(nil).Method1), s)
}

// Method2 mocks base method.
func (m *MockFirstModel) Method2(i int) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Method2", i)
	ret0, _ := ret[0].(int)
	return ret0
}

// Method2 indicates an expected call of Method2.
func (mr *MockFirstModelMockRecorder) Method2(i interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Method2", reflect.TypeOf((*MockFirstModel)(nil).Method2), i)
}
```
テストコード本体を書いてみます。
`interface.go`と同階層に`mock_test.go`というテストファイルを作成します。
今回はGoのテストでBasicとされているデフォルト内蔵の`Testing`パッケージを使用してinterfaceのテストを実現します。

```go
package mockTest

import (
  myMock "interface-test/mockTest/mock" //ver1.12でも相対PATHではだめそう。
	"fmt"
	"github.com/golang/mock/gomock"
	"testing"
)

const (
	NTR_FMT = "\n%+v\n"
)

func TestFirstMock(t *testing.T) {
  // モックコントローラの初期化を行う
	mockCtrl := gomock.NewController(t)
	fmt.Printf(NTR_FMT, mockCtrl)
	defer mockCtrl.Finish()
  //モック化したinterfaceモデルを初期化
	mockModel := myMock.NewMockFirstModel(mockCtrl)
	fmt.Printf(NTR_FMT, mockModel)

	mockModel.EXPECT().Method1("Testing").Return("Succeess!!")
	t.Log("result:", mockModel.Method1("Testing"))

	mockModel.EXPECT().Method2(1).Return(0)
	t.Log("result:", mockModel.Method2(1))
}
```

テストの実行
```sh
$ go test -v
=== RUN   TestFirstMock

&{T:0xc0000c2100 mu:{state:0 sema:0} expectedCalls:0xc0000902d0 finished:false}

&{ctrl:0xc0000922a0 recorder:0xc0000d2000}
--- PASS: TestFirstMock (0.00s)
    mock_test.go:23: result: Succeess!!
    mock_test.go:26: result: 0
PASS
ok  	interface-test/mockTest	0.112s
```

### 3.Mockを実装してみる

mockを実行するにあたり、`interface`について理解しておく必要があるので、復習がてらに記述しておきます。

```go
package main

import (
	"fmt"
	"log"
)

type MyInterface interface {
	Method(args []string) (string, error)
}

type ImplA struct{}

func (a *ImplA) Method(args []string) (string, error) {
	return fmt.Sprintf("Implementation By ImplA"), nil
}

type ImplB struct{}

func (b *ImplB) Method(args []string) (string, error) {
	return fmt.Sprintf("Implementation By ImplB"), nil
}

func main() {
	var a, b MyInterface
	a = &ImplA{}
	b = &ImplB{}

	fmt.Println(a.Method([]string{}))
	fmt.Println(b.Method([]string{}))
}

```
コンソールログ
```sh
Implementation By ImplA <nil>
Implementation By ImplB <nil>
```
